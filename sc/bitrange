#!/usr/bin/env python3
'''
Compute all bit signatures with a given maximum number of bits between two
given values.

This helper script takes an interval of floating point numbers between 0 and 1
and computes all floating point numbers in this interval which can be
represented by a given number of bits after the decimal point within that interval.

So, if the parameters '0.0 1.0 2' are given, the numbers 1/4, 1/2 and 3/4 are
computed, which in binary are 0.01, 0.1 and 0.11. Zero is always excluded.

The output is just a list of the binary representations of these numbers,
omitting the part before the decimal point (so 01 1 11).
'''

from sys import argv,exit

if (len(argv) != 4):
    print(argv[0],"pmin pmax maxbits")
    exit()

pmin = max(0,float(argv[1]))
pmax = min(1,float(argv[2]))
maxbits = int(argv[3])

class bitfield:
    def __init__(self):
        self.p = 0
        self.bits = []
        self.lsb = 1 #value of least significant bit
    def append(self,border):
        """add another bit such that the value is still below border"""
        self.lsb /= 2.0
        if self.p + self.lsb < border:
            val = 1
            self.p += self.lsb
        else:
            val = 0
        self.bits = [val] + self.bits
    def inc(self):
        self.p += 2**(-len(self.bits))
        for i in range(len(self.bits)):
            if self.bits[i] == 0:
                self.bits[i] = 1
                break
            else:
                self.bits[i] = 0
    def __repr__(self):
        s = ''
        for i in self.bits:
            if s=='' and i==0:
                continue
            s = str(i)+s
        return s

b = bitfield()
inc = 1
for i in range(maxbits):
    b.append(pmin)

b.inc()
while b.p < pmax:
    print(b)
    b.inc()
